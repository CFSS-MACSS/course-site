---
title: "Control Structures"
author: "MACSS 30500 <br /> University of Chicago"
output:
  xaringan::moon_reader:
    css: xaringan-themer.css
    nature:
      highlightStyle: magula
      highlightLines: true
      highlightLanguage: r
      ratio: 16:9
      countIncrementalSlides: false
---

```{r setup, include = FALSE}
# generate CSS file
library(xaringanthemer)
style_duo_accent(
  primary_color = "#011f4b",
  secondary_color = "#bbd6c7",
  inverse_header_color = "#222222",
  black_color = "#222222",
  header_font_google = xaringanthemer::google_font("Atkinson Hyperlegible"),
  text_font_google = xaringanthemer::google_font("Atkinson Hyperlegible"),
  code_font_google = xaringanthemer::google_font("Source Code Pro"),
  base_font_size = "24px",
  code_font_size = "20px",
  # title_slide_background_image = "https://github.com/uc-dataviz/course-notes/raw/main/images/hexsticker.svg",
  # title_slide_background_size = "contain",
  # title_slide_background_position = "top",
  header_h1_font_size = "2rem",
  header_h2_font_size = "1.75rem",
  header_h3_font_size = "1.5rem",
  extra_css = list(
    "h1" = list(
      "margin-block-start" = "0.4rem",
      "margin-block-end" = "0.4rem"
    ),
    "h2" = list(
      "margin-block-start" = "0.4rem",
      "margin-block-end" = "0.4rem"
    ),
    "h3" = list(
      "margin-block-start" = "0.4rem",
      "margin-block-end" = "0.4rem"
    ),
    ".tiny" = list("font-size" = "70%"),
    ".small" = list("font-size" = "90%"),
    ".midi" = list("font-size" = "150%"),
    ".tiny .remark-code" = list("font-size" = "70%"),
    ".small .remark-code" = list("font-size" = "90%"),
    ".midi .remark-code" = list("font-size" = "150%"),
    ".large" = list("font-size" = "200%"),
    ".xlarge" = list("font-size" = "600%"),
    ".huge" = list(
      "font-size" = "400%",
      "font-family" = "'Montserrat', sans-serif",
      "font-weight" = "bold"
    ),
    ".hand" = list(
      "font-family" = "'Gochi Hand', cursive",
      "font-size" = "125%"
    ),
    ".task" = list(
      "padding-right" = "10px",
      "padding-left" = "10px",
      "padding-top" = "3px",
      "padding-bottom" = "3px",
      "margin-bottom" = "6px",
      "margin-top" = "6px",
      "border-left" = "solid 5px #F1DE67",
      "background-color" = "#F3D03E"
    ),
    ".pull-left" = list(
      "width" = "49%",
      "float" = "left"
    ),
    ".pull-right" = list(
      "width" = "49%",
      "float" = "right"
    ),
    ".pull-left-wide" = list(
      "width" = "70%",
      "float" = "left"
    ),
    ".pull-right-narrow" = list(
      "width" = "27%",
      "float" = "right"
    ),
    ".pull-left-narrow" = list(
      "width" = "27%",
      "float" = "left"
    ),
    ".pull-right-wide" = list(
      "width" = "70%",
      "float" = "right"
    ),
    ".blue" = list(color = "#2A9BB7"),
    ".purple" = list(color = "#a493ba"),
    ".yellow" = list(color = "#f1de67"),
    ".gray" = list(color = "#222222")
  )
)

source(here::here("R", "slide-opts.R"))
xaringanExtra::use_panelset()
```

```{r pkgs, include = FALSE, cache = FALSE}
library(tidyverse)
library(rcis)
library(countdown)
library(modeldata)
library(here)

set.seed(1234)
theme_set(theme_minimal(base_size = 16))
```

class: inverse, middle

# Overview of control structures in R 

<!-- dropped from here vectors and lists, moved them to the data structure lecture 
added here conditional statements and more on iteration -->

---

## Control Structures in R

* All programs we have written so far can be seen as a finite and fixed sequence of commands.
* Control structures allow us to vary our commands by controlling their flow of execution. 
* How? by adding some “logic” into our R code, rather than executing the same R code every time.

---

## Control Structures in R

The main control structures are:

* **`if... else` statements**: test a condition(s) and act on it
* **`for` loop**: execute a loop a fixed number of times
* **`while` loop**: execute a loop while a condition is true

See Chapter 13 “Control Structures” in *R programming for Data Science* and Chapter 21 “Iteration” in *R for Data Science* for more in-depth info.

---

class: inverse, middle

# Conditional Statements: if... else

---

### If-else 

The if-else combination allows you to test a condition and act on it, depending on whether the condition is evaluated TRUE or FALSE.

Syntax:
```
if (condition) {
    action performed if condition is TRUE
} 
else {
    action performed if condition is FALSE
}
```

Example:
```{r}
age <- 14
if (age > 16) {
  print("You are elegible to get a driving license")
} else {
  print("You cannot drive")
}
```

---

### If-else 

Example: What is the output of this code?
```{r, echo = TRUE, results = "hide"}
y <- 10
if (y < 20) {
  x <- "Too low" 
} else {
  x <- "Too high"
}
x
```

---

### If-else 

Example: What is the output of this code?
```{r, echo = TRUE, results = "hide"}
my_numbers <- c(3,4,5,"6",7)

if(!is.numeric(my_numbers)) {
  print("At least one argument is not numeric. Only provide numbers.")
} else {
  print("All numeric elements")
}
```

---

### If, else if, else

We can expand the basic if-else structure to incorporate multiple tests using `else if`


Syntax:
```
if (condition 1) {
    action 1 performed when condition 1 is TRUE
} 
else if (condition 2) {
    action 2 performed when condition 2 is TRUE
}
else {
    action performed when condition 2 is FALSE
}
```

---

### If, else if, else

We can expand the basic if-else structure to incorporate multiple tests using `else if`

Example:
```{r}
x <- 0

# check if x is positive or negative or zero
if (x > 0) {
  print("x is a positive number")
} else if (x < 0) {
  print("x is a negative number")
} else {
  print("x is zero")
}
```

---

### Nested if-else

We can also write nested if-else statement to specify conditions inside conditions:

```{r}
x <- 15

# check if x is positive
if (x > 0) {
  # execute if x is positive: check if x is even or odd
  if (x %% 2 == 0) {
    print("x is a positive even number")
  } else {
    print("x is a positive odd number")
  }

# execute if x is not positive
} else {
  # check if x is even or odd
  if (x %% 2 == 0) {
    print("x is a negative even number")
  } else {
    print("x is a negative odd number")
  }
}
```

---

### ifelse()

R accepts `if()` and `else()` statements, but also statements using the built-in `ifelse()` function. Notice, there is a `dplyr` version of `ifelse()`, called `if_else()`: [documentation](https://dplyr.tidyverse.org/reference/if_else.html)


Syntax:
```
ifelse (condition to be evaluated,
        when condition is TRUE, this action will be performed,
        when condition is FALSE, this other action will be performed)
```

Example:
```{r}
y <- 3
ifelse(sqrt(16) > y, 
       sqrt(16),
       0)
```

---

### ifelse()

Example: What is the output of this code?
```{r, echo = TRUE, results = "hide"}
numbers <- c(10, 6, 7)
ifelse(numbers %% 2 == 1, 
       "odd", 
       "even")
```

---

### ifelse()

Example: What is the output of this code?
```{r, echo = TRUE, results = "hide"}
qualify <- data.frame("Athlet" = c("Noah", "Julio", "Nick", "Maria"), 
                      "Scores" = c(32, 37, 28, 30))

ifelse(qualify$"Scores" > 30, "Admitted", "Rejected")
```

<!--
More on this:
https://docs.ycrc.yale.edu/r-novice-gapminder/07-control-flow/
Comparing ifelse() and for loop:
https://www.r-bloggers.com/2020/02/if-else-and-ifelse/
-->

---

class: inverse, middle

# Practice writing if-else statements

---

class: inverse, middle

# Iteration: For loops

---

### For loops

For loops are the most common looping construct. Used to iterate over the elements of an object (list, vector, etc.) and apply some statement(s) to each of them (e.g., we do something with that element)

Syntax:
```
for (item in sequence of items) {
    statement(s)    
}
```

Example:
```{r}
for (i in 1:3){
  print(i)
}
```

---

### For loops 

Example:
```{r}
for (i in 1:3){
  print(i)
}
```

* Here the statement we are executing is simple: we just print `i` using the `print()` function. But at each iteration of the loop, the element `i` varies. 
* The number of repetitions of the statement block depends on the number of items in the sequence, in this example 3
* `i` can be called anything else

---

### For loops

Another example:
```{r}
for (i in 1:3){
  print(i)
  print("Hello")
  sum <- i + 100
  print(sum)
}
```

<!-- What is this loop doing? Have someone describing it 
what happens if I add a print(i) at the end outside the loop: prints last i-->


---

### Nested for loops

- The outer loop takes control of the number of complete repetitions of the inner loop.
- The inner loop is executed N-times for every execution of the outer loop.

```{r}
for (i in 1:3) {
  print(i)
  for (j in c('a', 'b')) {
    print(j)
  }
}
```

<!--
for (i in 1:3) {
  print(i)
  for (j in c('a', 'b')) {
    print(i)
    print(paste(i, "outer"))
    print(j)
    print(paste(i,j))
  }
}
-->

---

### Same operation without and with a for loop on a data frame

Get the data and remove missing rows:
```{r}
library(palmerpenguins)
data(penguins)
p <- drop_na(penguins)

glimpse(penguins)
```

---

### Same operation without and with a for loop on a data frame

Calculate the mean value per each column **without a loop**:
```{r, collapse = TRUE}
mean(p$bill_length_mm)
mean(p$bill_depth_mm)
mean(p$flipper_length_mm)
mean(p$body_mass_g)
```

How can we do the same **with a for loop**? In-class demo 

---

### Same operation without and with a for loop on a data frame

Calculate the median value per each column **with a for loop**:
```{r}
# initialize empty vector to store results
output <- vector(mode = "double", length = ncol(p))

# loop 
for (i in seq_along(p)) {
  output[[i]] <- mean(p[[i]])
}
output
```
---

class: inverse, middle

# Practice writing for loops

---

class: inverse, middle

# Iteration: While loops

---

### While loops

* While loops begin by evaluating a condition. 
* If the condition is TRUE, then they execute the loop body. 
* Once the loop body is executed, R starts over: the condition is tested again, and so forth, until the condition is FALSE, after which the loop exits. 

Best used when you do not know how long the input sequence should run for. For example, you might want to loop until you get three heads in a row. You can’t do that with a for loop.

Syntax:
```
while (condition) {
statement(s)
}
```
---

### While loops

Syntax:
```
while (condition) {
statement(s)
}
```

Example:
```{r}
counter <- 1

while(counter <= 5) {
  print(counter)
  counter <- counter + 1
}
```

---

### While loops

Example: What is the output of this code?
```
counter <- 1
while(counter < 4){
  print(counter)
}
```

---

### While loops

Example: What is the output of this code?
```{r}
counter <- 1
while(counter < 4){
  print(counter)
  multiply <- counter * 100
  print(multiply)
  counter <- counter + 1
  print(counter)
}
```


---

class: inverse, middle

# Iteration: For loops alternatives in R 

### Iteration with `map_*()` functions

---

## Map functions

`for` loops are good, but `map()` functions may be better

Types of `map()` functions:
- `map()` makes a list
-`map_lgl()` makes a logical vector
- `map_int()` makes an integer vector
- `map_dbl()` makes a double vector
- `map_chr()` makes a character vector

---

## Map functions

car_prices data frame:
```{r}
library(modeldata)
data(car_prices)
head(car_prices)
```

---

## Map functions

car_prices data frame:
```{r}
map_dbl(car_prices, median)
map_dbl(car_prices, sd)
```

---

class: inverse, middle

# Practice writing `map_*()` functions


---

class: inverse, middle

# Iteration: For loops alternatives in R 

### Iteration in data frames with `across()`

---

### Single column

```{r cp-mean-single-column}
car_prices %>%
  summarize(Price = mean(Price))
```

---

### Multiple columns

```{r}
car_prices %>%
  summarize(
    Price = mean(Price),
    Mileage = mean(Mileage),
    Cylinder = mean(Cylinder),
    Doors = mean(Doors),
    Cruise = mean(Cruise),
    Sound = mean(Sound),
    Leather = mean(Leather),
    Buick = mean(Buick),
    Cadillac = mean(Cadillac),
    Chevy = mean(Chevy),
    Pontiac = mean(Pontiac),
    Saab = mean(Saab),
    Saturn = mean(Saturn),
    convertible = mean(convertible),
    coupe = mean(coupe),
    hatchback = mean(hatchback),
    sedan = mean(sedan),
    wagon = mean(wagon)
  )
```

---

## `dplyr::across()`

`across()` has two primary arguments:

* `.cols`, selects the columns you want to operate on
* `.fns`, is a function or list of functions to apply to each column

---

## `summarize()`, `across()`, and `everything()`

.panelset[
.panel[.panel-name[Single function]
```{r summarize-across-everything}
car_prices %>%
  summarize(across(.cols = everything(), .fns = mean))
```
]

.panel[.panel-name[Multiple functions]
```{r summarize-across-everything-fns}
car_prices %>%
  summarize(across(everything(), .fns = list(min, max)))
```
]

.panel[.panel-name[Multiple named functions]
```{r summarize-across-everything-fns-named}
car_prices %>%
  summarize(across(everything(), .fns = list(min = min, max = max)))
```
]

.panel[.panel-name[Grouped by]
```{r summarize-across-everything-group-by}
car_prices %>%
  group_by(Cylinder) %>%
  summarize(across(everything(), .fns = mean))
```
]
]

---

## `worldbank`

```{r worldbank}
data("worldbank", package = "rcis")
worldbank
```

---

## `summarize()`, `across()`, and `where()`

.panelset[
.panel[.panel-name[Single condition]
```{r summarize-across-where}
worldbank %>%
  group_by(country) %>%
  summarize(across(.cols = where(is.numeric), .fns = mean, na.rm = TRUE))
```
]

.panel[.panel-name[Compound condition]
```{r summarize-across-compound}
worldbank %>%
  group_by(country) %>%
  summarize(across(
    .cols = where(is.numeric) & starts_with("perc"),
    .fn = mean, na.rm = TRUE
  ))
```
]

]

---

## `across()` and `mutate()`

```{r mutate-across}
car_prices %>%
  mutate(across(.cols = Price:Doors, .fns = log10))
```

---

## ~~`across()`~~ and `filter()`

.panelset[
.panel[.panel-name[`if_any()`]
```{r filter-if-any}
worldbank %>%
  filter(if_any(everything(), ~ !is.na(.x)))
```
]

.panel[.panel-name[`if_all()`]
```{r filter-if-all}
worldbank %>%
  filter(if_all(everything(), ~ !is.na(.x)))
```
]
]

---

class: inverse, middle

# Practice using `across()` iteration

---

## Acknowledgments 

The content of these slides is derived in part from Benjamin Soltoff’s “Computing for the Social Sciences” course materials, licensed under the CC BY NC 4.0 Creative Commons License. Any errors or oversights are mine alone.